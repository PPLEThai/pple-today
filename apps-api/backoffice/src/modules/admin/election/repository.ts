import { ElectionStatus, FilePath } from '@pple-today/api-common/dtos'
import { FileService, PrismaService } from '@pple-today/api-common/services'
import { err, fromRepositoryPromise } from '@pple-today/api-common/utils'
import {
  ElectionKeysStatus,
  ElectionMode,
  ElectionOnlineResultStatus,
  ElectionResultType,
  ElectionType,
  EligibleVoterType,
  Prisma,
} from '@pple-today/database/prisma'
import Elysia from 'elysia'
import { ok } from 'neverthrow'

import { AdminCreateElectionCandidateBody } from './models'

import { FileServicePlugin } from '../../../plugins/file'
import { PrismaServicePlugin } from '../../../plugins/prisma'

export class AdminElectionRepository {
  constructor(
    private readonly prismaService: PrismaService,
    private readonly fileService: FileService
  ) {}

  private resultTypesMap = {
    [ElectionType.ONSITE]: [ElectionResultType.ONSITE],
    [ElectionType.ONLINE]: [ElectionResultType.ONLINE],
    [ElectionType.HYBRID]: [ElectionResultType.ONSITE, ElectionResultType.ONLINE],
  } as const

  private voterTypesMap = {
    [ElectionType.ONSITE]: [EligibleVoterType.ONSITE],
    [ElectionType.ONLINE]: [EligibleVoterType.ONLINE],
    [ElectionType.HYBRID]: [EligibleVoterType.ONSITE],
  }

  private getCountElectionQuery() {
    return {
      select: {
        voters: true,
        voteRecords: true,
      },
    }
  }

  async createElection(input: {
    id?: string // if not specified, it will be generated by function
    name: string
    description?: string | null
    location?: string | null
    locationMapUrl?: string | null
    province: string
    district: string
    type: ElectionType
    mode?: ElectionMode
    keysStatus: ElectionKeysStatus
    openRegister?: Date | null
    closeRegister?: Date | null
    openVoting: Date
    closeVoting: Date
  }) {
    return fromRepositoryPromise(
      this.prismaService.election.create({
        data: {
          ...input,
        },
        include: {
          _count: this.getCountElectionQuery(),
        },
      })
    )
  }

  async updateElection(
    electionId: string,
    input: {
      name: string
      description?: string | null
      location?: string | null
      locationMapUrl?: string | null
      province?: string
      district?: string
      type: ElectionType
      openRegister?: Date | null
      closeRegister?: Date | null
      openVoting: Date
      closeVoting: Date
    }
  ) {
    return fromRepositoryPromise(
      this.prismaService.$transaction(async (tx) => {
        const election = await tx.election.update({
          where: { id: electionId },
          data: { ...input },
          include: {
            candidates: true,
            voters: true,
            _count: this.getCountElectionQuery(),
          },
        })

        await Promise.all([
          tx.electionEligibleVoter.deleteMany({ where: { electionId } }),
          tx.electionResult.deleteMany({ where: { candidate: { electionId } } }),
        ])

        const results = this.resultTypesMap[input.type].flatMap((type) =>
          election.candidates.map((candidate) => ({
            candidateId: candidate.id,
            count: 0,
            type,
          }))
        ) satisfies Prisma.ElectionResultCreateManyInput[]

        const voters = this.voterTypesMap[input.type].flatMap((type) =>
          election.voters.map((voter) => ({
            userId: voter.userId,
            electionId,
            type,
          }))
        ) satisfies Prisma.ElectionEligibleVoterCreateManyInput[]

        await Promise.all([
          tx.electionResult.createMany({ data: results }),
          tx.electionEligibleVoter.createMany({ data: voters }),
        ])

        return election
      })
    )
  }

  async deleteElection(electionId: string) {
    return fromRepositoryPromise(
      this.prismaService.election.delete({
        where: { id: electionId },
      })
    )
  }

  async makeElectionSecureMode(
    electionId: string,
    now: Date,
    destroyKeyInfo?: {
      at: Date
      duration: number
    }
  ) {
    return fromRepositoryPromise(
      this.prismaService.$transaction(async (tx) => {
        const election = await tx.election.update({
          where: { id: electionId },
          data: {
            mode: ElectionMode.SECURE,
            keysStatus: destroyKeyInfo && ElectionKeysStatus.DESTROY_SCHEDULED,
            keysDestroyScheduledAt: destroyKeyInfo?.at,
            keysDestroyScheduledDuration: destroyKeyInfo?.duration,
          },
        })

        if (election.closeVoting && now >= election.closeVoting) {
          await tx.electionVoteRecord.updateMany({
            where: { electionId },
            data: { ballotId: null },
          })
        }
      })
    )
  }

  async listElections(input: {
    filter?: {
      name?: string
      type?: ElectionType
      isCancelled?: boolean
      status?: ElectionStatus[]
    }
    pagination: {
      page: number
      limit: number
    }
    now: Date
  }) {
    const { page, limit } = input.pagination
    const skip = Math.max((page - 1) * limit, 0)

    const baseFilter: Prisma.ElectionWhereInput = {
      name: {
        contains: input.filter?.name,
        mode: 'insensitive',
      },
      type: input.filter?.type,
      isCancelled: input.filter?.isCancelled,
    }

    const statusFilter: Prisma.ElectionWhereInput =
      input.filter?.status
        ?.map((status) => {
          switch (status) {
            case 'DRAFT':
              return { publishDate: null }
            case 'NOT_OPENED_VOTE':
              return { publishDate: { not: null }, openVoting: { gt: input.now } }
            case 'OPEN_VOTE':
              return {
                publishDate: { not: null },
                openVoting: { lte: input.now },
                closeVoting: { gt: input.now },
              }
            case 'CLOSED_VOTE':
              return {
                publishDate: { not: null },
                closeVoting: { lte: input.now },
                OR: [{ startResult: null }, { startResult: { gt: input.now } }],
              }
            case 'RESULT_ANNOUNCE':
              return {
                publishDate: { not: null },
                startResult: { lte: input.now },
              }
            default:
              return null
          }
        })
        .filter((filter) => filter)
        .reduce((prev, curr) => ({ OR: [prev, curr] }), {}) || {}

    const filter = { ...baseFilter, ...statusFilter }

    return fromRepositoryPromise(async () => {
      const [data, count] = await Promise.all([
        this.prismaService.election.findMany({
          where: filter,
          include: {
            _count: this.getCountElectionQuery(),
          },
          orderBy: {
            updatedAt: 'desc',
          },
          take: limit,
          skip,
        }),
        this.prismaService.election.count({
          where: filter,
        }),
      ])

      return {
        data,
        count,
      }
    })
  }

  async getElectionById(electionId: string) {
    return fromRepositoryPromise(
      this.prismaService.election.findUniqueOrThrow({
        where: { id: electionId },
        include: {
          _count: this.getCountElectionQuery(),
        },
      })
    )
  }

  async getElectionByCandidateId(candidateId: string) {
    return fromRepositoryPromise(async () => {
      const candidate = await this.prismaService.electionCandidate.findUniqueOrThrow({
        where: {
          id: candidateId,
        },
        select: {
          election: true,
        },
      })
      return candidate.election
    })
  }

  async cancelElectionById(electionId: string) {
    return fromRepositoryPromise(
      this.prismaService.$transaction([
        this.prismaService.electionBallot.deleteMany({ where: { electionId } }),
        this.prismaService.election.update({
          where: { id: electionId },
          data: { isCancelled: true },
        }),
      ])
    )
  }

  async publishElectionById(electionId: string, publishDate: Date) {
    return fromRepositoryPromise(
      this.prismaService.election.update({
        where: { id: electionId },
        data: { publishDate },
      })
    )
  }

  async listElectionCandidates(electionId: string) {
    return fromRepositoryPromise(
      this.prismaService.electionCandidate.findMany({
        where: { electionId },
      })
    )
  }

  async updateElectionKeys(
    electionId: string,
    keys: {
      status: ElectionKeysStatus
      encryptionPublicKey?: string
      signingPublicKey?: string
    }
  ) {
    return fromRepositoryPromise(
      this.prismaService.election.update({
        where: {
          id: electionId,
        },
        data: {
          keysStatus: keys.status,
          encryptionPublicKey: keys.encryptionPublicKey,
          signingPublicKey: keys.signingPublicKey,
        },
      })
    )
  }

  async createElectionCandidate(electionId: string, data: AdminCreateElectionCandidateBody) {
    const moveFileResult = await fromRepositoryPromise(
      this.fileService.$transaction(async (tx) => {
        const profileImage = data.profileImagePath
        if (!profileImage) return null

        const moveFileResult = await tx.bulkMoveToPublicFolder([profileImage])
        if (moveFileResult.isErr()) return err(moveFileResult.error)

        return moveFileResult.value[0]
      })
    )
    if (moveFileResult.isErr()) return err(moveFileResult.error)

    const [newProfileImagePath, fileTx] = moveFileResult.value

    const createCandidateResult = await fromRepositoryPromise(async () => {
      const election = await this.prismaService.election.findUniqueOrThrow({
        where: { id: electionId },
        select: { type: true },
      })

      const results = this.resultTypesMap[election.type].map((type) => ({ type, count: 0 }))

      return this.prismaService.electionCandidate.create({
        data: {
          electionId,
          name: data.name,
          description: data.description,
          profileImagePath: newProfileImagePath,
          number: data.number,
          results: { createMany: { data: results } },
        },
      })
    })
    if (createCandidateResult.isErr()) {
      const rollbackResult = await fileTx.rollback()
      if (rollbackResult.isErr()) return err(rollbackResult.error)
      return err(createCandidateResult.error)
    }

    return ok(createCandidateResult.value)
  }

  async updateElectionCandidate(candidateId: string, data: AdminCreateElectionCandidateBody) {
    const candidateResult = await fromRepositoryPromise(
      this.prismaService.electionCandidate.findUniqueOrThrow({
        where: { id: candidateId },
      })
    )
    if (candidateResult.isErr()) return err(candidateResult.error)

    const moveFileResult = await fromRepositoryPromise(
      this.fileService.$transaction(async (tx) => {
        const newProfileImage = data.profileImagePath
        const oldProfileImage = candidateResult.value.profileImagePath

        if (newProfileImage === oldProfileImage) return

        if (oldProfileImage) {
          const deleteOldFileResult = await tx.deleteFile(oldProfileImage as FilePath)
          if (deleteOldFileResult.isErr()) return err(deleteOldFileResult.error)
        }

        if (newProfileImage) {
          const moveNewFileResult = await tx.bulkMoveToPublicFolder([newProfileImage])
          if (moveNewFileResult.isErr()) return err(moveNewFileResult.error)
          return moveNewFileResult.value[0]
        }

        return null
      })
    )
    if (moveFileResult.isErr()) return err(moveFileResult.error)

    const [newProfileImage, fileTx] = moveFileResult.value

    const updateCandidateResult = await fromRepositoryPromise(
      this.prismaService.electionCandidate.update({
        where: { id: candidateId },
        data: {
          name: data.name,
          description: data.description,
          profileImagePath: newProfileImage,
          number: data.number,
        },
      })
    )

    if (updateCandidateResult.isErr()) {
      const rollbackResult = await fileTx.rollback()
      if (rollbackResult.isErr()) return err(rollbackResult.error)
      return err(updateCandidateResult.error)
    }

    return ok(updateCandidateResult.value)
  }

  async deleteElectionCandidate(candidateId: string) {
    const candidateResult = await fromRepositoryPromise(
      this.prismaService.electionCandidate.findUniqueOrThrow({
        where: { id: candidateId },
      })
    )
    if (candidateResult.isErr()) return err(candidateResult.error)

    const deleteProfileImageResult = await fromRepositoryPromise(
      this.fileService.$transaction(async (tx) => {
        const profileImage = candidateResult.value.profileImagePath
        if (!profileImage) return
        const deleteProfileImage = await tx.deleteFile(profileImage as FilePath)
        if (deleteProfileImage.isErr()) return err(deleteProfileImage.error)
      })
    )
    if (deleteProfileImageResult.isErr()) return err(deleteProfileImageResult.error)

    const [_, fileTx] = deleteProfileImageResult.value

    const deleteResult = await fromRepositoryPromise(
      this.prismaService.electionCandidate.delete({
        where: { id: candidateId },
      })
    )
    if (deleteResult.isErr()) {
      const rollbackResult = await fileTx.rollback()
      if (rollbackResult.isErr()) return err(rollbackResult.error)
      return err(deleteResult.error)
    }

    return ok()
  }

  async listElectionEligibleVoters(electionId: string, isRegistered?: boolean) {
    const registerFilter =
      isRegistered !== undefined
        ? {
            election: { type: ElectionType.HYBRID },
            type: isRegistered ? EligibleVoterType.ONLINE : EligibleVoterType.ONSITE,
          }
        : {}

    return fromRepositoryPromise(
      this.prismaService.electionEligibleVoter.findMany({
        where: { electionId, ...registerFilter },
        select: {
          user: {
            select: {
              id: true,
              phoneNumber: true,
            },
          },
        },
      })
    )
  }

  async filterExistUserIds(userIds: string[]) {
    return fromRepositoryPromise(async () => {
      const existUserIds = await this.prismaService.user.findMany({
        where: {
          id: {
            in: userIds,
          },
        },
        select: {
          id: true,
        },
      })

      const existUserIdsSet = new Set(existUserIds.map(({ id }) => id))
      return userIds.filter((userId) => !existUserIdsSet.has(userId))
    })
  }

  async listUserIdsFromPhoneNumbers(phoneNumbers: string[]) {
    return fromRepositoryPromise(async () => {
      const users = await this.prismaService.user.findMany({
        where: {
          phoneNumber: {
            in: phoneNumbers,
          },
        },
        select: {
          id: true,
          phoneNumber: true,
        },
      })

      const existPhoneNumberSet = new Set(users.map(({ phoneNumber }) => phoneNumber))
      const nonExistPhoneNumbers = phoneNumbers.filter(
        (phoneNumber) => !existPhoneNumberSet.has(phoneNumber)
      )
      const userIds = users.map(({ id }) => id)

      return {
        userIds,
        nonExistPhoneNumbers,
      }
    })
  }

  async bulkCreateElectionEligibleVoterByUserIds(
    electionId: string,
    voterType: EligibleVoterType,
    userIds: string[]
  ) {
    return fromRepositoryPromise(
      this.prismaService.electionEligibleVoter.createManyAndReturn({
        data: userIds.map((userId) => ({
          userId,
          electionId,
          type: voterType,
        })),
        skipDuplicates: true,
      })
    )
  }

  async bulkDeleteElectionEligibleVoterByUserIds(electionId: string, userIds: string[]) {
    return fromRepositoryPromise(
      this.prismaService.electionEligibleVoter.deleteMany({
        where: {
          electionId,
          userId: {
            in: userIds,
          },
        },
      })
    )
  }

  async bulkDeleteElectionEligibleVoterByPhoneNumber(electionId: string, phoneNumbers: string[]) {
    return fromRepositoryPromise(
      this.prismaService.electionEligibleVoter.deleteMany({
        where: {
          electionId,
          user: {
            phoneNumber: {
              in: phoneNumbers,
            },
          },
        },
      })
    )
  }

  async countElectionEligibleVoters(electionId: string, type: EligibleVoterType) {
    return fromRepositoryPromise(
      this.prismaService.electionEligibleVoter.count({
        where: {
          electionId,
          type,
        },
      })
    )
  }

  private async upsertElectionResult(
    tx: Prisma.TransactionClient,
    electionId: string,
    type: ElectionResultType,
    result: { candidateId: string; votes: number }[]
  ) {
    const [election] = await Promise.all([
      tx.election.findUniqueOrThrow({
        where: {
          id: electionId,
        },
        select: {
          candidates: true,
        },
      }),
      tx.electionResult.updateMany({
        where: {
          candidate: { electionId },
          type,
        },
        data: { count: 0 },
      }),
    ])

    const candidateIds = new Set(election.candidates.map((candidate) => candidate.id))
    const validResults = result.filter((r) => candidateIds.has(r.candidateId))
    const invalidCandidateIds = result
      .filter((r) => !candidateIds.has(r.candidateId))
      .map((r) => r.candidateId)

    await tx.electionInvalidBallot.createMany({
      data: invalidCandidateIds.map((candidateId) => ({
        candidateId,
        electionId,
      })),
    })

    for (let i = 0; i < result.length; i += 5) {
      const endIdx = Math.min(i + 5, result.length)
      const batch = validResults.slice(i, endIdx)

      await Promise.all(
        batch.map(({ candidateId, votes }) =>
          tx.electionResult.upsert({
            where: {
              candidateId_type: {
                candidateId,
                type,
              },
            },
            create: {
              candidateId,
              type,
              count: votes,
            },
            update: {
              count: votes,
            },
          })
        )
      )
    }
  }

  async uploadElectionOnsiteResult(
    electionId: string,
    result: { candidateId: string; votes: number }[]
  ) {
    return fromRepositoryPromise(
      this.prismaService.$transaction(async (tx) =>
        this.upsertElectionResult(tx, electionId, ElectionResultType.ONSITE, result)
      )
    )
  }

  private async updateOnlineResultStatus(
    tx: Prisma.TransactionClient,
    electionId: string,
    status: ElectionOnlineResultStatus
  ) {
    await tx.election.update({
      where: { id: electionId },
      data: { onlineResultStatus: status },
    })
  }

  async uploadFailedElectionOnlineResult(electionId: string) {
    return fromRepositoryPromise(
      this.prismaService.$transaction(async (tx) =>
        this.updateOnlineResultStatus(tx, electionId, ElectionOnlineResultStatus.COUNT_FAILED)
      )
    )
  }

  async uploadSuccessElectionOnlineResult(
    electionId: string,
    result: { candidateId: string; votes: number }[]
  ) {
    return fromRepositoryPromise(
      this.prismaService.$transaction(async (tx) =>
        Promise.all([
          this.updateOnlineResultStatus(tx, electionId, ElectionOnlineResultStatus.COUNT_SUCCESS),
          this.upsertElectionResult(tx, electionId, ElectionResultType.ONLINE, result),
        ])
      )
    )
  }

  async listElectionBallots(electionId: string) {
    return fromRepositoryPromise(
      this.prismaService.electionBallot.findMany({
        where: {
          electionId,
        },
        select: {
          encryptedBallot: true,
        },
      })
    )
  }

  async unlinkVoteRecordsToBallots(electionId: string) {
    return fromRepositoryPromise(
      this.prismaService.electionVoteRecord.updateMany({
        where: { electionId },
        data: { ballotId: null },
      })
    )
  }

  async getElectionResult(electionId: string) {
    return fromRepositoryPromise(
      this.prismaService.election.findUniqueOrThrow({
        where: { id: electionId },
        include: {
          candidates: {
            include: {
              results: true,
            },
            orderBy: [
              {
                number: 'asc',
              },
              {
                id: 'asc',
              },
            ],
          },
          _count: {
            select: { voters: true },
          },
        },
      })
    )
  }

  async announceElectionResult(
    electionId: string,
    timeline: {
      start: Date
      end: Date
    },
    destroyKeyInfo?: {
      at: Date
      duration: number
    }
  ) {
    return fromRepositoryPromise(
      this.prismaService.election.update({
        where: { id: electionId },
        data: {
          startResult: timeline.start,
          endResult: timeline.end,
          keysStatus: destroyKeyInfo && ElectionKeysStatus.DESTROY_SCHEDULED,
          keysDestroyScheduledAt: destroyKeyInfo?.at,
          keysDestroyScheduledDuration: destroyKeyInfo?.duration,
        },
      })
    )
  }
}

export const AdminElectionRepositoryPlugin = new Elysia({ name: 'AdminElectionRepository' })
  .use([PrismaServicePlugin, FileServicePlugin])
  .decorate(({ prismaService, fileService }) => ({
    adminElectionRepository: new AdminElectionRepository(prismaService, fileService),
  }))
